# 동적계획법
## 1. 동적계획법의 소개
### 01 피보나치 수
* n번째 달에 a쌍의 토끼가 존재
* n+1번째 달에 b쌍의 토끼가 존재
* ==> n+2번째 달에는 a+b쌍의 토끼가 존재하게 됨

* f(n+2) = f(n) + f(n+1)
  * 재귀함수로 구현함

```
# 재귀 함수
# 문제: 중복 호출이 생겨 비효율적
def fibo(n):
  if n<2: return n
  else: return fibo(n-1) + fibo(n-2)
```



### 02 수학적 귀납법과 비둘기 집의 원리
#### 1) 수학적 귀납법
* 목적: 피보나치 함수에서 중복 호출을 알기 위함
* 어떤 등식이 모든 n에 대해 성립함을 보이기 위해서, 가능한 모든 n을 등식에 대입해 증명할 수 없음  
==> 주어진 등식이 n=1일 때 성립함을 증명하고 n일 때 성립한다고 가정한 후 n+1일 때 성립함을 증명

* 증명과정
  * 1. 귀납 기본: n=1(혹은 n=0)에 대해 등식이 성립함을 증명
  * 2. 귀납 가정: 임의의 n에 대해 등식이 성립한다고 가정
  * 3. 귀납 단계: 등식이 n+1에 대해서도 성립함을 증명

#### 2) 비둘기 집의 원리
* n+1개의 물건을 n개의 상자에 넣을 때 적어도 어느 한 상자에는 두개 이상의 물건이 들어 있다는 원리
* 증명: 귀류법으로
  * n개의 비둘기 집과 n+1마리의 비둘기
  * 만약 각 비둘기 집에 한 마리 이하의 비둘기만 들어 있다면 전체 비둘기 집에는 많아야 n마리의 비둘기 존재
  * 비둘기 모두 n+1마리, 이것은 모순 -> 따라서 어느 비둘기 집에는 두마리 이상의 비둘기 존재

* 예제
  * 서울에는 머리카락의 수가 같은 사람이 최소 두명 존재
  * 13명이 모여있다면 같은 달에 태어난 사람이 최소 두명 존재
  * 피보나치 수열의 중복
    * n번째의 피보나치 수를 구하기 위해 알아야 할 값
      * fibo(0) - fibo(n-1)까지의 값을 알면 fibo(n)을 구할 수 있음
      * fibo() 함수를 n번 호출해 값을 알면 구할 수 있음
    * n번째 피보나치 수를 구하기 위해 재귀 호출로 작성된 fibo(n) 함수 호출
      * fibo() 함수를 2^n/2 번 이상 호출
      * 2^n/2 > n (for n>=2)
    * 비둘기 집의 원리를 적용하면 중복해서 호출하고 있음을 확인 가능

### 03 메모이제이션과 동적 동적계획법
#### 1) 메모이제이션
* 컴퓨터 프로그램 실행 시 이전에 계산한 값을 메모리에 저장, 매번 다시 계산하지 않도록 해 전체적인 실행속도를 빠르게 하는 기술
* 동적 계획법의 핵심이 되는 기술
* 피보나치 함수의 메모이제이션 적용
  * 피보나치 함수: 실행속도 저하 or 메모리 오버플로우 발생

#### 2) 동적 계획 알고리즘
* 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘
  * 최적화 문제- 최적(최대값 or 최소값) 값을 구하는 문제
  * 작은 부분 문제들의 해 => 해를 이용해 보다 큰 크기의 부분 문제 해결 => 최종적으로 원래 주어진 문제 해결
* 완전검색을 더 효율적으로 하는 방법: recursive(점화식 찾기) + memoization
* 적용 문제의 요건
  * 중복 부분문제 구조:
    * 작은 문제들의 최적 해를 이용해 더 큰 문제의 최적 해를 구함
    * 순환적 해결(점화식 사용)
    * 이미 해결된 작은 문제들의 최적 해는 memoization 기법을 이용해 저장함
  * 최적 부분문제 구조:
    * 동적 계획법이 어느 최적화 문제에나 적용되지 않음
    * 최적화의 원칙
      * 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야
      * if 큰 문제의 최적 해가 작은 문제들의 최적 해들로 구성되지 않는다면 해당 문제는 동적 계획법으로 풀 수 없음(예: 최장 경로 문제)
  * 분할 정복 vs 동적 계획법
* 부분문제들 사이에 의존적 관계가 존재하게 됨
  * 상향식 방법으로 접근
* 적용
```
def fibo_dp(n):
  f[0] = 0
  f[1] = 1
  for i in range(2, n+1):
    f[i] = f[i+1] + f[i+2]
  return f[n]
```

### 04 동전 거스름돈 문제와 이항 계수 문제
#### 1) 동전 거스름돈 문제
* 거스름돈 8원에 대한 재귀적인 알고리즘
  * 3가지 동전 각각을 선택해서 재귀적으로 해결
  * 상태 공간 트리: 중복이 생김
  * 중복을 피하기 위해서는 메모이제이션을 적용
* 동적 계획법 접근: 상향식

#### 2) 이항 계수 문제
* 이항 정리
* 이항 계수 구하는 공식
* 파스칼의 삼각형: 이항 계수를 구하는 방법과 동일
* 재귀 호출을 이용해 이항 계수를 구하는 알고리즘
```
def bino(n,k):
  if k == 0 or k == n:
    return 1
  else:
  return bino(n-1,k-1) + bino(n-1,k)
```

* 메모이제이션을 이용한 이항 계수의 계산
```
def bino1(n,k):
  if k==0 or k==n: return 1
  if B[n][k] != -1:
    return B[n][k]
  else:
    B[n][k] = bino1(n-1, k-1) + bino1(n-1,k)
    return B[n][k]
```

* 동적 계획법을 적용한 이항계수 계산: O(nk)
```
def bino2(n,k):
  for i in range(n+1):
    for j in range(min(i,k)+1):
      if j==0 or j==i:
        B[i][j] = 1
      else:
        B[i][j] = B[i-1][j-1] + B[i-1][j]
  return B[n][k]
```
