# minCost.py
# 5250. [파이썬 S/W 문제해결 구현] 7일차 - 최소 비용
# 다익스트라 알고리즘 변형해서 이용
# 미완: 노드와 간선으로 구성된 무방향 그래프에서 다익스트라로 만들어 주기
'''
출발에서 최종 도착지까지 경유하는 지역의 높이 차이에 따라 연료 소비량이 달라지기 때문에, 최적의 경로로 이동하면 최소한의 연료로 이동할 수 있다.

다음은 각 지역의 높이를 기록한 표의 예로, 항상 출발은 맨 왼쪽 위, 도착지는 가장 오른쪽 아래이며, 각 칸에서는 상하좌우 칸이 나타내는 인접 지역으로만 이동할 수 있다.

(표에 표시되지 않은 지역이나 대각선 방향으로는 이동 불가.)

0 2 1
0 1 1
1 1 1

인접 지역으로 이동시에는 기본적으로 1만큼의 연료가 들고, 더 높은 곳으로 이동하는 경우 높이 차이만큼 추가로 연료가 소비된다.

색이 칠해진 칸을 따라 이동하는 경우(0-0-1-1-1) 기본적인 연료 소비량 4에, 높이가 0에서 1로 경우만큼 추가 연료가 소비되므로 최소 연료 소비량 5로 목적지에 도착할 수 있다.

이동 가능한 지역의 높이 정보에 따라 최소 연료 소비량을 출력하는 프로그램을 만드시오.

[입력]

첫 줄에 테스트 케이스의 개수 T가 주어지고, 테스트 케이스 별로 첫 줄에 표의 가로, 세로 칸수N, 다음 줄부터 N개 지역의 높이 H가 N개의 줄에 걸쳐 제공된다.

1<=T<=50, 3<=N<=100, 0<=H<1000

3
3
0 2 1
0 1 1
1 1 1
5
0 0 0 0 0
0 1 2 3 0
0 2 3 4 0
0 3 4 5 0
0 0 0 0 0
5
0 1 1 1 0
1 1 0 1 0
0 1 0 1 0
1 0 0 1 1
1 1 1 1 1

[출력]

각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.

#1 5
#2 8
#3 9

'''

'''sol
1. 우선 아래처럼 0만 채워진 reg에서 가는 지점마다의 연료를 표기한 fue는 아래와 같음
<reg>     <fue>
0 0 0     0 1 2
0 0 0 ==> 1 2 3
0 0 0     2 3 4
BUT 높이차이가 50이거나 그럴 수 있으므로: 4방향 다 고려해야 함...? 
* 문제: 언제 해야 할 지 모르겠음.

2. 이전 위치까지 쓴 연료 + 기본값 1 + 경사에 쓰인 연료
    * 이전 위치까지 쓴 연료 = {x==0: 선택지=왼쪽만, y==0: 선택지=위쪽만, else: min(위쪽, 왼쪽)}
        ==> 예외는 처음 x==0 and y==0 인덱스: 이건 스스로 그대로.
    * 경사에 쓰인 연료 = {if 높이차이 > 0: 그대로, else: 0}
'''

def main():
    T = int(input())
    for t in range(T):
        n = int(input())
        reg = []
        for _ in range(n):
            reg.append([int(i) for i in input().split()])
        # print(reg)
        print("#%d %d"%(t+1, minCost(reg)))


def minCost(reg):
    # reg는 2차원 n*n list
    '''
    return 도착지까지 계산한 최소한의 연료
    le_dif, to_dif 각각 직전 위치와 현재 위치의 높이 차이: le은 왼쪽과 차이, to는 위쪽과 차이
    beNh = 직전 위치까지 쓴 최소 연료 + 높이 차이로 쓰인 연료(음수 또는 0일 경우 0으로 반영)
    * 2차원 리스트는 [:][:]도 얕은 복사임: 따라서 [[0]*3]*3과 같은 형식을 이용해야 함
    '''
    fue = [[0]*len(reg)]*len(reg)
    for x in range(len(fue)):
        for y in range(len(fue[x])):
            if x == 0 and y == 0:
                # 1. fue[0][0]: reg[0][0] 값으로 초기화시켜주기
                fue[x][y] = reg[x][y]
            else:
                # 2. x != 0 or y != 0일 때 그 위치까지 쓰는 최소한의 연료 업데이트
                if x == 0:
                    # (1) 맨 위 엣지: 왼쪽, 아래, 오른쪽..? 선택 가능
                    le_dif = reg[x][y] - reg[x][y-1]
                    beNh = fue[x][y-1]
                    beNh += le_dif if le_dif > 0 else 0
                elif y == 0:
                    # (2) 맨 왼쪽 엣지: 위쪽만 선택 가능
                    to_dif = reg[x][y] - reg[x-1][y]
                    beNh = fue[x-1][y]
                    beNh += to_dif if to_dif > 0 else 0
                else:
                    # (3) 가운데 위치 & 오른쪽아래 엣지: 위, 왼쪽 위치 모두 선택 가능
                    # 이때 최소값으로 선택해 주기
                    le_dif = reg[x][y] - reg[x][y-1]
                    to_dif = reg[x][y] - reg[x-1][y]

                    lef_h = le_dif if le_dif > 0 else 0
                    top_h = to_dif if to_dif > 0 else 0
                    beNh = min(fue[x-1][y] + top_h, fue[x][y-1] + lef_h)
                # (5) 공통: 위치를 옮기면 연료 +1이 되므로 +1해서 업데이트해 주기
                fue[x][y] = beNh + 1
    # print(reg)
    # print(fue)
    # 3. 도착지의 fue 값 리턴해주기
    return fue[len(fue)-1][len(fue)-1]


main()