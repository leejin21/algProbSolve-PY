# 문자열 탐색
## 01 해싱
* 특정 항목 검색 시, 탐색 키에 대한 산술적 연산으로 키가 있는 위치를 계산해 바로 찾아가는 방법

#### 1. 직접 번지 테이블과 해시 테이블
* 직접 번지 테이블(배열)
* 전체 키(key) 들의 집합(U)이 작은 경우에 효율적
    * 키 k가 테이블(T)에서 위치 k에 저장
    * 테이블(배열) 크기 = 집합 U의 크기

* 해시 테이블
    * 모든 가능한 키들의 집합 U에 비해 실제 사용되는 키들의 집합 K가 작을 경우
    * 저장 공간을 세타(|K|)로 줄임
    * 키 값 k의 자료를 저장할 위치를 계산하는 해시 함수(h) 사용
    * 키 값이 k인 자료를 h(k)의 위치에 저장

* 해시 함수

#### 2. 충돌
* 충돌
    * 서로 다른 키 값을 해시 함수에 적용했는데 반환된 해시 주소가 동일한 경우
    * 해시 함수가 아무리 해시 주소를 공평하게 분배해도 해시 테이블에 저장되는 키에 해당하는 자료의 수가 증가하면 충돌 불가피

* 충돌의 해결 방법
*체이닝*
    * 해시 테이블의 구조를 변경하여 각 버킷에 하나 이상의 키 값을 가지는 자료가 저장될 수 있도록 하는 방법
    * 하나의 버킷에 여러 개의 키 값을 저장할 수 있도록 ==> 연결 리스트

*개방 주소법*
    * 빈 공간이 없어 충돌이 발생하면, 그 다음 공간에 빈 공간 여부를 조사
    * 빈 공간이 있으면, 탐색키에 대한 항목 저장
    * 빈 공간이 없으면, 공간이 나올 때까지 탐색을 반복


## 02 문자열 매칭(패턴 매칭)
텍스트 문자열(t)에 패턴 문자열(p) 포함 여부를 찾는 것

#### 1. 고지식한 알고리즘(Brute Force)
* 일일이 비교하는 방식으로. 불일치가 발생하는 경우 텍스트의 시작은 그 다음 위치. 패턴의 시작은 항상 처음
* O(mn)

#### 2. 카프-라빈(Karp-Rabin) 알고리즘
* 최악: O(MN), 평균: 선형에 가까운
* 숫자로 변환 후 4자리씩 읽어서 비교하는 알고리즘, 이전 해시 값을 이용해서 다음 해시 값을 구함
* 고려사항
    * 처음 해시 값을 구할 때는 찾고자 하는 문자열에서 패턴 길이 만큼 읽어서 구함  
    * 패턴의 길이가 커지면 길이를 일정 자리수로 맞추기 위해 Mod 연산 진행  
    * 해시 값이 일치하면 실제 문자열이 일치하는 지 검사

#### 3. KMP 알고리즘
* O(m+n)
* 접두어와 접미어: 문자열의 길이만큼 존재
> https://bowbowbow.tistory.com/6  
> https://jason9319.tistory.com/130

* 실패함수 pi[x]
: 검색하려는 문자열 B의 0번째~x번째 위치까지 볼 때 접두어==접미어가 되는 최대 접두어(접미어) 길이

#### 4. 보이어 무어 알고리즘
* 패턴의 오른쪽 끝 -> 왼쪽과 일치하는 지
* 일치하는 것을 보고 점프
    * 패턴의 오른쪽 끝과 비교했을 때 패턴에 속한 문자일 경우 정해 둔 칸수만큼 shift, else 패턴 문자열 길이만큼.

#### ++ 파이썬 내장 함수
* in
* find()

## 03 트라이
#### 1. 접미어 트라이
* 문자열의 모든 접미어를 Trie로 표현
* 문자열 연산:
  1. 부분 문자열 검사: 간선들을 따라가면 됨
  2. 최장 공통 접두어는 무엇인가?
  3. 사전적 순서로 정렬된 k번째 접미어 찾기
      * 사전적 순서로 정렬  
      * 인덱스 값만 저장  
* 압축된 트라이
  * 1개의 자식만 있는 노드들을 하나의 간선으로 묶어서 표현


## 04 접미어 배열
#### 1. 복잡도
* 메모리 크기: O(n)
* O(nlogn) 시간에 생성
* 텍스트 T에 패턴 P의 존재를 O(|P|+logn)시간에 계산
#### 2. 장점
* 생성 방법이 접미어 트리에 비해 간단
* 적은 메모리로 구현 가능
  - 2개의 선형 크기의 리스트로 구성
  - 전형적 접미어 트리* 1/4 크기의 메모리 사용
#### 3. 생성
추가적으로 LCP 배열 생성
1. 설명
    * LCP: 접미어 배열의 보조적인 자료 구조로 최장 공통 접두어 배열 생성
    * 정렬된 접미어 배열에서 연속적인 2개의 접미어들 사이의 최장 공통 접두어의 길이 저장
    * 접미어 배열의 순회/패턴 매칭 효율 수행 위해 사용
2. LCP 배열
    * 추가 공부 필요(이해 필요)


## 05 데이터 압축
#### 1. 용어
* 인코딩과 디코딩
    - 인코딩: 데이터 압축
    - 디코딩: 데이터 복구
    - 압축률: 압축 데이터의 비트 수/ 바이너리 데이터의 비트 수
    - 데이터 압축
        - 손실
        - 무손실 압축

#### 2. RLE: Run Length Encoding
* 동일한 값(코드)이 몇 번 반복되는가를 나타내는 방식
    * Run - 반복되는 문자
    * Length - 반복 횟수

* 이미지 파일 포맷인 BMP 파일 포맷의 압축 방법으로 사용

#### 3. 허프만 코드
* 기호의 빈도: 전체 데이터 안에서 차지하는 기호의 빈도
* 허프만 트리: 각 기호에 이진 코드를 부여하기 위해 생성하는 이진 트리
* 고정 길이 코드와 접두어 코드
    * 고정 길이 코드
    : 기호에 대응하는 코드 값의 길이가 똑같은 코드체계(ex: 아스키)
    * 접두어 코드
    : 가변 길이 코드의 한 종류, 어느 코드가 다른 코드의 접두어가 되지 않는 코드체계

#### 4. 허프만 트리
* 트리가 존재하지 않고, 문자들에 대한 노드들만 있다고 가정
* 해 선택
    * 빈도가 가장 작은 노드 2개 선, 이들의 부모 노드 생성
    * 부모 노드의 빈도 = 자식 노드 빈도의 합
* 실행 가능성 검사
    * 허프만 트리의 노드 규칙(어느 코드가 다른 코드의 접두어가 되지 않는 지)에 위배되지 않는지 검사
* 해 검사
    * 추가할 노드(기호)가 남아 있으면 해가 아니므로 앞의 과정 반복
